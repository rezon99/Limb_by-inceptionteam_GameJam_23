"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instrumentHttpServerWithPromClientRegistry = exports.getDefaultHttpMetrics = exports.httpLabels = void 0;
const http_server_1 = require("@well-known-components/http-server");
const interfaces_1 = require("@well-known-components/interfaces");
exports.httpLabels = ["method", "handler", "code"];
const metrics = {
    http_request_duration_seconds: {
        type: interfaces_1.IMetricsComponent.HistogramType,
        help: "Request duration in seconds.",
        labelNames: exports.httpLabels,
    },
    http_requests_total: {
        type: interfaces_1.IMetricsComponent.CounterType,
        help: "Total number of HTTP requests",
        labelNames: exports.httpLabels,
    },
    http_request_size_bytes: {
        type: interfaces_1.IMetricsComponent.HistogramType,
        help: "Duration of HTTP requests size in bytes",
        labelNames: exports.httpLabels,
    },
};
/**
 * @public
 */
function getDefaultHttpMetrics() {
    return metrics;
}
exports.getDefaultHttpMetrics = getDefaultHttpMetrics;
const noopStartTimer = { end() { } };
function instrumentHttpServerWithPromClientRegistry(options) {
    const router = new http_server_1.Router();
    if (!options.metrics.registry) {
        throw new Error("The provisioned metrics do not have a valid prom-client registry");
    }
    function calculateNextReset() {
        return new Date(new Date(new Date().toDateString()).getTime() + 86400000).getTime();
    }
    let nextReset = calculateNextReset();
    const registry = options.metrics.registry;
    // TODO: optional basic auth for /metrics
    router.get(options.metricsPath, async (ctx) => {
        if (options.bearerToken) {
            const header = ctx.request.headers.get("authorization");
            if (!header)
                return { status: 401 };
            const [_, value] = header.split(" ");
            if (value != options.bearerToken) {
                return { status: 401 };
            }
        }
        const body = await registry.metrics();
        // heavy-metric servers that run for long hours tend to generate precision problems
        // and memory degradation for histograms if not cleared enough. this method
        // resets the metrics once per day at 00.00UTC
        if (options.resetEveryNight && Date.now() > nextReset) {
            nextReset = calculateNextReset();
            options.metrics.resetAll();
        }
        return {
            status: 200,
            body,
            headers: {
                "content-type": registry.contentType,
            },
        };
    });
    options.server.use(async (ctx, next) => {
        let labels = {
            method: ctx.request.method,
            handler: "",
            code: 200,
        };
        const startTimerResult = options.metrics.startTimer("http_request_duration_seconds", labels);
        const end = (startTimerResult === null || startTimerResult === void 0 ? void 0 : startTimerResult.end) || noopStartTimer.end;
        let res;
        try {
            return (res = await next());
        }
        finally {
            labels.code = (res && res.status) || labels.code;
            if (ctx.routerPath) {
                labels.handler = ctx.routerPath;
            }
            options.metrics.observe("http_request_size_bytes", labels, ctx.request.size);
            options.metrics.increment("http_requests_total", labels);
            end(labels);
        }
    });
    options.server.use(router.middleware());
}
exports.instrumentHttpServerWithPromClientRegistry = instrumentHttpServerWithPromClientRegistry;
//# sourceMappingURL=http.js.map