"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMetricsDeclaration = exports.instrumentHttpServerWithMetrics = exports.createMetricsComponent = exports._configKey = exports.CONFIG_PREFIX = exports.getDefaultHttpMetrics = exports.createTestMetricsComponent = void 0;
const prom_client_1 = require("prom-client");
const http_1 = require("./http");
Object.defineProperty(exports, "getDefaultHttpMetrics", { enumerable: true, get: function () { return http_1.getDefaultHttpMetrics; } });
const base_1 = require("./base");
Object.defineProperty(exports, "createTestMetricsComponent", { enumerable: true, get: function () { return base_1.createTestMetricsComponent; } });
/**
 * Metrics configuration prefix.
 * @public
 */
exports.CONFIG_PREFIX = "WKC_METRICS";
/**
 * @internal
 */
function _configKey(key) {
    return `${exports.CONFIG_PREFIX}_${key.toUpperCase().replace(/^(_*)/, "")}`;
}
exports._configKey = _configKey;
/**
 * @public
 */
async function createMetricsComponent(metricsDefinition, components) {
    const { config } = components;
    const basePort = (0, base_1.createTestMetricsComponent)(metricsDefinition);
    return Object.assign(Object.assign({}, basePort), { 
        // IBaseComponent
        start: async () => {
            if ((await config.getString(_configKey("COLLECT_DEFAULT"))) != "false") {
                (0, prom_client_1.collectDefaultMetrics)({ register: basePort.registry });
            }
        } });
}
exports.createMetricsComponent = createMetricsComponent;
/**
 * Instruments an HTTP server with a IMetricsComponent created by this library
 *
 * @public
 */
async function instrumentHttpServerWithMetrics(components) {
    const metricsPath = (await components.config.getString(_configKey("PUBLIC_PATH"))) || "/metrics";
    const bearerToken = await components.config.getString(_configKey("BEARER_TOKEN"));
    const rotateMetrics = await components.config.getString(_configKey("RESET_AT_NIGHT")) == 'true';
    (0, http_1.instrumentHttpServerWithPromClientRegistry)({
        server: components.server,
        metrics: components.metrics,
        metricsPath,
        bearerToken,
        resetEveryNight: rotateMetrics
    });
}
exports.instrumentHttpServerWithMetrics = instrumentHttpServerWithMetrics;
/**
 * This function only validates the types.
 * In the future it may perform real runtime assertions.
 *
 * @public
 */
function validateMetricsDeclaration(metricsDefinition) {
    return metricsDefinition;
}
exports.validateMetricsDeclaration = validateMetricsDeclaration;
//# sourceMappingURL=index.js.map