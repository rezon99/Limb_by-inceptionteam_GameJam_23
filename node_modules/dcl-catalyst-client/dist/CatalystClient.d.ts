/// <reference types="node" />
import { Entity } from '@dcl/schemas';
import { Fetcher, HealthStatus, RequestOptions } from 'dcl-catalyst-commons';
import { CatalystAPI } from './CatalystAPI';
import { BuildEntityOptions, BuildEntityWithoutFilesOptions } from './ContentClient';
import { EmotesFilters, OwnedItems, ServerMetadata, WearablesFilters } from './LambdasAPI';
import { DeploymentBuilder, DeploymentData, DeploymentPreparationData } from './utils/DeploymentBuilder';
export declare type CatalystClientOptions = {
    catalystUrl: string;
    fetcher?: Fetcher;
    deploymentBuilderClass?: typeof DeploymentBuilder;
};
export declare class CatalystClient implements CatalystAPI {
    private readonly contentClient;
    private readonly lambdasClient;
    private readonly catalystUrl;
    constructor(options: CatalystClientOptions);
    buildEntity(options: BuildEntityOptions): Promise<DeploymentPreparationData>;
    buildEntityWithoutNewFiles(options: BuildEntityWithoutFilesOptions): Promise<DeploymentPreparationData>;
    /** @deprecated use deploy instead */
    deployEntity(deployData: DeploymentData, fix?: boolean, options?: RequestOptions): Promise<number>;
    deploy(deployData: DeploymentData, options?: RequestOptions): Promise<unknown>;
    fetchEntitiesByPointers(pointers: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntitiesByIds(ids: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntityById(id: string, options?: RequestOptions): Promise<Entity>;
    downloadContent(contentHash: string, options?: RequestOptions): Promise<Buffer>;
    fetchProfiles(ethAddresses: string[], options?: RequestOptions): Promise<any[]>;
    fetchWearables(filters: WearablesFilters, options?: RequestOptions): Promise<any[]>;
    fetchOwnedWearables<B extends boolean>(ethAddress: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchOwnedThirdPartyWearables<B extends boolean>(ethAddress: string, thirdPartyId: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchEmotes(filters: EmotesFilters, options?: RequestOptions): Promise<any[]>;
    fetchOwnedEmotes<B extends boolean>(ethAddress: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchOwnedThirdPartyEmotes<B extends boolean>(ethAddress: string, thirdPartyId: string, includeDefinitions: B, options?: RequestOptions): Promise<OwnedItems<B>>;
    fetchCatalystsApprovedByDAO(options?: RequestOptions): Promise<ServerMetadata[]>;
    fetchLambdasStatus(options?: RequestOptions): Promise<{
        contentServerUrl: string;
    }>;
    fetchPeerHealth(options?: RequestOptions): Promise<Record<string, HealthStatus>>;
    getCatalystUrl(): string;
    getContentUrl(): string;
    getLambdasUrl(): string;
    static connectedToCatalystIn(options: CatalystConnectOptions): Promise<CatalystClient>;
}
export declare type CatalystConnectOptions = {
    network: 'mainnet' | 'goerli';
};
