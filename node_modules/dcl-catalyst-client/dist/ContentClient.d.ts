/// <reference types="node" />
import { Entity, EntityType } from '@dcl/schemas';
import { Fetcher, RequestOptions } from 'dcl-catalyst-commons';
import FormData from 'form-data';
import { AvailableContentResult, ContentAPI } from './ContentAPI';
import { DeploymentBuilder, DeploymentData, DeploymentPreparationData } from './utils/DeploymentBuilder';
export declare type ContentClientOptions = {
    contentUrl: string;
    fetcher?: Fetcher;
    deploymentBuilderClass?: typeof DeploymentBuilder;
};
export declare class ContentClient implements ContentAPI {
    private readonly contentUrl;
    private readonly fetcher;
    private readonly deploymentBuilderClass;
    constructor(options: ContentClientOptions);
    buildEntityWithoutNewFiles({ type, pointers, hashesByKey, metadata, timestamp }: BuildEntityWithoutFilesOptions): Promise<DeploymentPreparationData>;
    buildEntity({ type, pointers, files, metadata, timestamp }: BuildEntityOptions): Promise<DeploymentPreparationData>;
    buildEntityFormDataForDeployment(deployData: DeploymentData, options?: RequestOptions): Promise<FormData>;
    deployEntity(deployData: DeploymentData, fix?: boolean, options?: RequestOptions): Promise<number>;
    deploy(deployData: DeploymentData, options?: RequestOptions): Promise<unknown>;
    fetchEntitiesByPointers(pointers: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntitiesByIds(ids: string[], options?: RequestOptions): Promise<Entity[]>;
    fetchEntityById(id: string, options?: RequestOptions): Promise<Entity>;
    downloadContent(contentHash: string, options?: Partial<RequestOptions>): Promise<Buffer>;
    isContentAvailable(cids: string[], options?: RequestOptions): Promise<AvailableContentResult>;
    getContentUrl(): string;
    /** Given an array of file hashes, return a set with those already uploaded on the server */
    private hashesAlreadyOnServer;
}
export interface BuildEntityOptions {
    type: EntityType;
    pointers: string[];
    files?: Map<string, Uint8Array>;
    metadata?: any;
    timestamp?: number;
}
export interface BuildEntityWithoutFilesOptions {
    type: EntityType;
    pointers: string[];
    hashesByKey?: Map<string, string>;
    metadata?: any;
    timestamp?: number;
}
export declare class DeploymentFields {
    private readonly fields;
    static readonly AUDIT_INFO: DeploymentFields;
    static readonly POINTERS_CONTENT_METADATA_AND_AUDIT_INFO: DeploymentFields;
    static readonly POINTERS_CONTENT_AND_METADATA: DeploymentFields;
    private constructor();
    getFields(): string;
    isFieldIncluded(name: string): boolean;
}
