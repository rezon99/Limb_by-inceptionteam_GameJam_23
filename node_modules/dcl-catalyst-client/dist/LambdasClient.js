"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdasClient = void 0;
const dcl_catalyst_commons_1 = require("dcl-catalyst-commons");
const Helper_1 = require("./utils/Helper");
class LambdasClient {
    constructor(options) {
        this.lambdasUrl = (0, Helper_1.sanitizeUrl)(options.lambdasUrl);
        this.fetcher = options.fetcher
            ? options.fetcher
            : new dcl_catalyst_commons_1.Fetcher({
                headers: (0, Helper_1.getHeadersWithUserAgent)('lambdas-client')
            });
    }
    async fetchProfiles(ethAddresses, options) {
        if (ethAddresses.length === 0) {
            return Promise.resolve([]);
        }
        const requestOptions = (0, dcl_catalyst_commons_1.mergeRequestOptions)(options ? options : {}, {
            body: JSON.stringify({ ids: ethAddresses }),
            headers: { 'Content-Type': 'application/json' },
            method: 'POST'
        });
        return (await this.fetcher.fetch(`${this.lambdasUrl}/profiles`, requestOptions)).json();
    }
    fetchWearables(filters, options) {
        const queryParams = (0, Helper_1.convertFiltersToQueryParams)(filters);
        if (queryParams.size === 0) {
            throw new Error('You must set at least one filter');
        }
        return (0, Helper_1.splitAndFetchPaginated)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: '/collections/wearables',
            queryParams,
            uniqueBy: 'id',
            elementsProperty: 'wearables',
            options
        });
    }
    fetchOwnedWearables(ethAddress, includeDefinitions, options) {
        return (0, Helper_1.splitAndFetch)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: `/collections/wearables-by-owner/${ethAddress}`,
            queryParams: { name: 'includeDefinitions', values: [`${includeDefinitions}`] },
            options
        });
    }
    fetchOwnedThirdPartyWearables(ethAddress, thirdPartyId, includeDefinitions, options) {
        const queryParams = new Map([
            ['collectionId', [thirdPartyId]],
            ['includeDefinitions', [`${includeDefinitions}`]]
        ]);
        return (0, Helper_1.splitAndFetch)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: `/collections/wearables-by-owner/${ethAddress}`,
            queryParams,
            options
        });
    }
    fetchEmotes(filters, options) {
        const queryParams = (0, Helper_1.convertFiltersToQueryParams)(filters);
        if (queryParams.size === 0) {
            throw new Error('You must set at least one filter');
        }
        return (0, Helper_1.splitAndFetchPaginated)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: '/collections/emotes',
            queryParams,
            uniqueBy: 'id',
            elementsProperty: 'emotes',
            options
        });
    }
    fetchOwnedEmotes(ethAddress, includeDefinitions, options) {
        return (0, Helper_1.splitAndFetch)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: `/collections/emotes-by-owner/${ethAddress}`,
            queryParams: { name: 'includeDefinitions', values: [`${includeDefinitions}`] },
            options
        });
    }
    fetchOwnedThirdPartyEmotes(ethAddress, thirdPartyId, includeDefinitions, options) {
        const queryParams = new Map([
            ['collectionId', [thirdPartyId]],
            ['includeDefinitions', [`${includeDefinitions}`]]
        ]);
        return (0, Helper_1.splitAndFetch)({
            fetcher: this.fetcher,
            baseUrl: this.lambdasUrl,
            path: `/collections/emotes-by-owner/${ethAddress}`,
            queryParams,
            options
        });
    }
    fetchCatalystsApprovedByDAO(options) {
        return this.fetcher.fetchJson(`${this.lambdasUrl}/contracts/servers`, options);
    }
    fetchLambdasStatus(options) {
        return this.fetcher.fetchJson(`${this.lambdasUrl}/status`, options);
    }
    fetchPeerHealth(options) {
        return this.fetcher.fetchJson(`${this.lambdasUrl}/health`, options);
    }
    getLambdasUrl() {
        return this.lambdasUrl;
    }
}
exports.LambdasClient = LambdasClient;
//# sourceMappingURL=LambdasClient.js.map