import * as BABYLON from '@babylonjs/core';
import { Entity } from '@dcl/ecs';
import * as components from '@dcl/ecs/dist/components';
import * as Schemas from '@dcl/schemas';
import { ComponentOperation } from './component-operations';
import { EcsEntity } from './EcsEntity';
export type LoadableScene = {
    readonly entity: Readonly<Omit<Schemas.Entity, 'id'>>;
    readonly baseUrl: string;
    readonly id: string;
};
export declare class SceneContext {
    #private;
    babylon: BABYLON.Engine;
    scene: BABYLON.Scene;
    loadableScene: LoadableScene;
    rootNode: EcsEntity;
    logger: {
        log: {
            (...data: any[]): void;
            (message?: any, ...optionalParams: any[]): void;
        };
        error: {
            (...data: any[]): void;
            (message?: any, ...optionalParams: any[]): void;
        };
    };
    engine: import("@dcl/ecs").IEngine;
    operations: {
        removeEntity: (entity: Entity) => void;
        updateValue: <T = unknown>(component: components.LastWriteWinElementSetComponentDefinition<T>, entity: Entity, data: Partial<T>) => void;
        addChild: (parent: Entity, value: string) => void;
        addAsset: (parent: Entity, src: string, name: string, position: import("@dcl/ecs").Vector3Type) => Entity;
        setParent: (entity: Entity, parent: Entity) => void;
        addComponent: (entity: Entity, componentId: number) => void;
        removeComponent: <T_1>(entity: Entity, component: components.LastWriteWinElementSetComponentDefinition<T_1>) => void;
        updateSelectedEntity: (entity: Entity) => void;
        removeSelectedEntities: () => void;
        duplicateEntity: (entity: Entity) => Entity;
        dispatch: ({ dirty }?: import("../../sdk/operations").Dispatch) => Promise<void>;
    };
    gizmos: {
        gizmoManager: import("./gizmo-patch").PatchedGizmoManager;
        setEntity(entity: EcsEntity | null): void;
        getEntity(): EcsEntity | null;
        unsetEntity(): void;
        getGizmoTypes(): readonly [import("../../utils/gizmo").GizmoType.POSITION, import("../../utils/gizmo").GizmoType.ROTATION, import("../../utils/gizmo").GizmoType.SCALE];
        setGizmoType(type: import("../../utils/gizmo").GizmoType): void;
        isPositionGizmoWorldAligned: () => boolean;
        setPositionGizmoWorldAligned: (worldAligned: boolean) => void;
        isRotationGizmoWorldAligned: () => boolean;
        setRotationGizmoWorldAligned: (worldAligned: boolean) => void;
        fixRotationGizmoAlignment: (value: import("@dcl/ecs").TransformType) => void;
        isRotationGizmoAlignmentDisabled: () => boolean;
        onChange: (cb: () => void) => () => void;
    };
    Billboard: components.LastWriteWinElementSetComponentDefinition<components.PBBillboard>;
    Transform: import("@dcl/ecs").TransformComponentExtended;
    Material: import("@dcl/ecs").MaterialComponentDefinitionExtended;
    MeshRenderer: import("@dcl/ecs").MeshRendererComponentDefinitionExtended;
    GltfContainer: components.LastWriteWinElementSetComponentDefinition<components.PBGltfContainer>;
    TextShape: components.LastWriteWinElementSetComponentDefinition<components.PBTextShape>;
    Name: components.LastWriteWinElementSetComponentDefinition<import("@dcl/ecs").NameType>;
    readonly editorComponents: import("../../sdk/components").EditorComponents;
    readonly componentPutOperations: Record<number, ComponentOperation>;
    readonly stopped: import("fp-future").IFuture<void>;
    constructor(babylon: BABYLON.Engine, scene: BABYLON.Scene, loadableScene: LoadableScene);
    private processEcsChange;
    removeEntity(entityId: Entity): void;
    getOrCreateEntity(entityId: Entity): EcsEntity;
    getEntityOrNull(entityId: Entity): EcsEntity | null;
    resolveFile(src: string): string | null;
    getFile(src: string): Promise<Uint8Array | null>;
    resolveFileAbsolute(src: string): string | null;
    dispose(): void;
}
