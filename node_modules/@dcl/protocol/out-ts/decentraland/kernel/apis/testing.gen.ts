/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.kernel.apis";

export interface TestResult {
  name: string;
  ok: boolean;
  error?: string | undefined;
  stack?:
    | string
    | undefined;
  /** how many ADR-148 ticks were spent running this test */
  totalFrames: number;
  /** total time in seconds spent running this test */
  totalTime: number;
}

export interface TestResultResponse {
}

export interface TestPlan {
  tests: TestPlan_TestPlanEntry[];
}

export interface TestPlan_TestPlanEntry {
  name: string;
}

export interface TestPlanResponse {
}

export interface SetCameraTransformTestCommand {
  position: SetCameraTransformTestCommand_Vector3 | undefined;
  rotation: SetCameraTransformTestCommand_Quaternion | undefined;
}

export interface SetCameraTransformTestCommand_Vector3 {
  x: number;
  y: number;
  z: number;
}

export interface SetCameraTransformTestCommand_Quaternion {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface SetCameraTransformTestCommandResponse {
}

function createBaseTestResult(): TestResult {
  return { name: "", ok: false, error: undefined, stack: undefined, totalFrames: 0, totalTime: 0 };
}

export namespace TestResult {
  export function encode(message: TestResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ok === true) {
      writer.uint32(16).bool(message.ok);
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    if (message.stack !== undefined) {
      writer.uint32(34).string(message.stack);
    }
    if (message.totalFrames !== 0) {
      writer.uint32(40).uint32(message.totalFrames);
    }
    if (message.totalTime !== 0) {
      writer.uint32(53).float(message.totalTime);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ok = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stack = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalFrames = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.totalTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestResult {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      ok: isSet(object.ok) ? Boolean(object.ok) : false,
      error: isSet(object.error) ? String(object.error) : undefined,
      stack: isSet(object.stack) ? String(object.stack) : undefined,
      totalFrames: isSet(object.totalFrames) ? Number(object.totalFrames) : 0,
      totalTime: isSet(object.totalTime) ? Number(object.totalTime) : 0,
    };
  }

  export function toJSON(message: TestResult): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.ok !== undefined && (obj.ok = message.ok);
    message.error !== undefined && (obj.error = message.error);
    message.stack !== undefined && (obj.stack = message.stack);
    message.totalFrames !== undefined && (obj.totalFrames = Math.round(message.totalFrames));
    message.totalTime !== undefined && (obj.totalTime = message.totalTime);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestResult>, I>>(base?: I): TestResult {
    return TestResult.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestResult>, I>>(object: I): TestResult {
    const message = createBaseTestResult();
    message.name = object.name ?? "";
    message.ok = object.ok ?? false;
    message.error = object.error ?? undefined;
    message.stack = object.stack ?? undefined;
    message.totalFrames = object.totalFrames ?? 0;
    message.totalTime = object.totalTime ?? 0;
    return message;
  }
}

function createBaseTestResultResponse(): TestResultResponse {
  return {};
}

export namespace TestResultResponse {
  export function encode(_: TestResultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): TestResultResponse {
    return {};
  }

  export function toJSON(_: TestResultResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestResultResponse>, I>>(base?: I): TestResultResponse {
    return TestResultResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestResultResponse>, I>>(_: I): TestResultResponse {
    const message = createBaseTestResultResponse();
    return message;
  }
}

function createBaseTestPlan(): TestPlan {
  return { tests: [] };
}

export namespace TestPlan {
  export function encode(message: TestPlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tests) {
      TestPlan_TestPlanEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tests.push(TestPlan_TestPlanEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestPlan {
    return {
      tests: Array.isArray(object?.tests) ? object.tests.map((e: any) => TestPlan_TestPlanEntry.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: TestPlan): unknown {
    const obj: any = {};
    if (message.tests) {
      obj.tests = message.tests.map((e) => e ? TestPlan_TestPlanEntry.toJSON(e) : undefined);
    } else {
      obj.tests = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlan>, I>>(base?: I): TestPlan {
    return TestPlan.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlan>, I>>(object: I): TestPlan {
    const message = createBaseTestPlan();
    message.tests = object.tests?.map((e) => TestPlan_TestPlanEntry.fromPartial(e)) || [];
    return message;
  }
}

function createBaseTestPlan_TestPlanEntry(): TestPlan_TestPlanEntry {
  return { name: "" };
}

export namespace TestPlan_TestPlanEntry {
  export function encode(message: TestPlan_TestPlanEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlan_TestPlanEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlan_TestPlanEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestPlan_TestPlanEntry {
    return { name: isSet(object.name) ? String(object.name) : "" };
  }

  export function toJSON(message: TestPlan_TestPlanEntry): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlan_TestPlanEntry>, I>>(base?: I): TestPlan_TestPlanEntry {
    return TestPlan_TestPlanEntry.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlan_TestPlanEntry>, I>>(
    object: I,
  ): TestPlan_TestPlanEntry {
    const message = createBaseTestPlan_TestPlanEntry();
    message.name = object.name ?? "";
    return message;
  }
}

function createBaseTestPlanResponse(): TestPlanResponse {
  return {};
}

export namespace TestPlanResponse {
  export function encode(_: TestPlanResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlanResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): TestPlanResponse {
    return {};
  }

  export function toJSON(_: TestPlanResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlanResponse>, I>>(base?: I): TestPlanResponse {
    return TestPlanResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlanResponse>, I>>(_: I): TestPlanResponse {
    const message = createBaseTestPlanResponse();
    return message;
  }
}

function createBaseSetCameraTransformTestCommand(): SetCameraTransformTestCommand {
  return { position: undefined, rotation: undefined };
}

export namespace SetCameraTransformTestCommand {
  export function encode(message: SetCameraTransformTestCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      SetCameraTransformTestCommand_Vector3.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.rotation !== undefined) {
      SetCameraTransformTestCommand_Quaternion.encode(message.rotation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = SetCameraTransformTestCommand_Vector3.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rotation = SetCameraTransformTestCommand_Quaternion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand {
    return {
      position: isSet(object.position) ? SetCameraTransformTestCommand_Vector3.fromJSON(object.position) : undefined,
      rotation: isSet(object.rotation) ? SetCameraTransformTestCommand_Quaternion.fromJSON(object.rotation) : undefined,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand): unknown {
    const obj: any = {};
    message.position !== undefined &&
      (obj.position = message.position ? SetCameraTransformTestCommand_Vector3.toJSON(message.position) : undefined);
    message.rotation !== undefined &&
      (obj.rotation = message.rotation ? SetCameraTransformTestCommand_Quaternion.toJSON(message.rotation) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand {
    return SetCameraTransformTestCommand.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand>, I>>(
    object: I,
  ): SetCameraTransformTestCommand {
    const message = createBaseSetCameraTransformTestCommand();
    message.position = (object.position !== undefined && object.position !== null)
      ? SetCameraTransformTestCommand_Vector3.fromPartial(object.position)
      : undefined;
    message.rotation = (object.rotation !== undefined && object.rotation !== null)
      ? SetCameraTransformTestCommand_Quaternion.fromPartial(object.rotation)
      : undefined;
    return message;
  }
}

function createBaseSetCameraTransformTestCommand_Vector3(): SetCameraTransformTestCommand_Vector3 {
  return { x: 0, y: 0, z: 0 };
}

export namespace SetCameraTransformTestCommand_Vector3 {
  export function encode(
    message: SetCameraTransformTestCommand_Vector3,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand_Vector3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand_Vector3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand_Vector3 {
    return {
      x: isSet(object.x) ? Number(object.x) : 0,
      y: isSet(object.y) ? Number(object.y) : 0,
      z: isSet(object.z) ? Number(object.z) : 0,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand_Vector3): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.z !== undefined && (obj.z = message.z);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Vector3>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand_Vector3 {
    return SetCameraTransformTestCommand_Vector3.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Vector3>, I>>(
    object: I,
  ): SetCameraTransformTestCommand_Vector3 {
    const message = createBaseSetCameraTransformTestCommand_Vector3();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  }
}

function createBaseSetCameraTransformTestCommand_Quaternion(): SetCameraTransformTestCommand_Quaternion {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export namespace SetCameraTransformTestCommand_Quaternion {
  export function encode(
    message: SetCameraTransformTestCommand_Quaternion,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand_Quaternion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand_Quaternion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand_Quaternion {
    return {
      x: isSet(object.x) ? Number(object.x) : 0,
      y: isSet(object.y) ? Number(object.y) : 0,
      z: isSet(object.z) ? Number(object.z) : 0,
      w: isSet(object.w) ? Number(object.w) : 0,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand_Quaternion): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.z !== undefined && (obj.z = message.z);
    message.w !== undefined && (obj.w = message.w);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Quaternion>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand_Quaternion {
    return SetCameraTransformTestCommand_Quaternion.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Quaternion>, I>>(
    object: I,
  ): SetCameraTransformTestCommand_Quaternion {
    const message = createBaseSetCameraTransformTestCommand_Quaternion();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  }
}

function createBaseSetCameraTransformTestCommandResponse(): SetCameraTransformTestCommandResponse {
  return {};
}

export namespace SetCameraTransformTestCommandResponse {
  export function encode(
    _: SetCameraTransformTestCommandResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommandResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): SetCameraTransformTestCommandResponse {
    return {};
  }

  export function toJSON(_: SetCameraTransformTestCommandResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommandResponse>, I>>(
    base?: I,
  ): SetCameraTransformTestCommandResponse {
    return SetCameraTransformTestCommandResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommandResponse>, I>>(
    _: I,
  ): SetCameraTransformTestCommandResponse {
    const message = createBaseSetCameraTransformTestCommandResponse();
    return message;
  }
}

export type TestingServiceDefinition = typeof TestingServiceDefinition;
export const TestingServiceDefinition = {
  name: "TestingService",
  fullName: "decentraland.kernel.apis.TestingService",
  methods: {
    /** sends a test result to the test runner */
    logTestResult: {
      name: "LogTestResult",
      requestType: TestResult,
      requestStream: false,
      responseType: TestResultResponse,
      responseStream: false,
      options: {},
    },
    /** send a list of all planned tests to the test runner */
    plan: {
      name: "Plan",
      requestType: TestPlan,
      requestStream: false,
      responseType: TestPlanResponse,
      responseStream: false,
      options: {},
    },
    /** sets the camera position and rotation in the engine */
    setCameraTransform: {
      name: "SetCameraTransform",
      requestType: SetCameraTransformTestCommand,
      requestStream: false,
      responseType: SetCameraTransformTestCommandResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
