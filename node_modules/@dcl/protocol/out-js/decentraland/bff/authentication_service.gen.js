"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BffAuthenticationServiceDefinition = exports.DisconnectionMessage = exports.WelcomePeerInformation = exports.SignedChallenge = exports.GetChallengeResponse = exports.GetChallengeRequest = exports.disconnectionReasonToJSON = exports.disconnectionReasonFromJSON = exports.DisconnectionReason = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const empty_gen_1 = require("../../google/protobuf/empty.gen");
exports.protobufPackage = "decentraland.bff";
var DisconnectionReason;
(function (DisconnectionReason) {
    DisconnectionReason[DisconnectionReason["DR_KICKED"] = 0] = "DR_KICKED";
    DisconnectionReason[DisconnectionReason["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DisconnectionReason = exports.DisconnectionReason || (exports.DisconnectionReason = {}));
function disconnectionReasonFromJSON(object) {
    switch (object) {
        case 0:
        case "DR_KICKED":
            return DisconnectionReason.DR_KICKED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DisconnectionReason.UNRECOGNIZED;
    }
}
exports.disconnectionReasonFromJSON = disconnectionReasonFromJSON;
function disconnectionReasonToJSON(object) {
    switch (object) {
        case DisconnectionReason.DR_KICKED:
            return "DR_KICKED";
        case DisconnectionReason.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.disconnectionReasonToJSON = disconnectionReasonToJSON;
function createBaseGetChallengeRequest() {
    return { address: "" };
}
var GetChallengeRequest;
(function (GetChallengeRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    }
    GetChallengeRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetChallengeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetChallengeRequest.decode = decode;
    function fromJSON(object) {
        return { address: isSet(object.address) ? String(object.address) : "" };
    }
    GetChallengeRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    }
    GetChallengeRequest.toJSON = toJSON;
    function create(base) {
        return GetChallengeRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetChallengeRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseGetChallengeRequest();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    GetChallengeRequest.fromPartial = fromPartial;
})(GetChallengeRequest = exports.GetChallengeRequest || (exports.GetChallengeRequest = {}));
function createBaseGetChallengeResponse() {
    return { challengeToSign: "", alreadyConnected: false };
}
var GetChallengeResponse;
(function (GetChallengeResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.challengeToSign !== "") {
            writer.uint32(10).string(message.challengeToSign);
        }
        if (message.alreadyConnected === true) {
            writer.uint32(16).bool(message.alreadyConnected);
        }
        return writer;
    }
    GetChallengeResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetChallengeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.challengeToSign = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.alreadyConnected = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetChallengeResponse.decode = decode;
    function fromJSON(object) {
        return {
            challengeToSign: isSet(object.challengeToSign) ? String(object.challengeToSign) : "",
            alreadyConnected: isSet(object.alreadyConnected) ? Boolean(object.alreadyConnected) : false,
        };
    }
    GetChallengeResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.challengeToSign !== undefined && (obj.challengeToSign = message.challengeToSign);
        message.alreadyConnected !== undefined && (obj.alreadyConnected = message.alreadyConnected);
        return obj;
    }
    GetChallengeResponse.toJSON = toJSON;
    function create(base) {
        return GetChallengeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetChallengeResponse.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseGetChallengeResponse();
        message.challengeToSign = (_a = object.challengeToSign) !== null && _a !== void 0 ? _a : "";
        message.alreadyConnected = (_b = object.alreadyConnected) !== null && _b !== void 0 ? _b : false;
        return message;
    }
    GetChallengeResponse.fromPartial = fromPartial;
})(GetChallengeResponse = exports.GetChallengeResponse || (exports.GetChallengeResponse = {}));
function createBaseSignedChallenge() {
    return { authChainJson: "" };
}
var SignedChallenge;
(function (SignedChallenge) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authChainJson !== "") {
            writer.uint32(10).string(message.authChainJson);
        }
        return writer;
    }
    SignedChallenge.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedChallenge();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.authChainJson = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SignedChallenge.decode = decode;
    function fromJSON(object) {
        return { authChainJson: isSet(object.authChainJson) ? String(object.authChainJson) : "" };
    }
    SignedChallenge.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.authChainJson !== undefined && (obj.authChainJson = message.authChainJson);
        return obj;
    }
    SignedChallenge.toJSON = toJSON;
    function create(base) {
        return SignedChallenge.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SignedChallenge.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseSignedChallenge();
        message.authChainJson = (_a = object.authChainJson) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    SignedChallenge.fromPartial = fromPartial;
})(SignedChallenge = exports.SignedChallenge || (exports.SignedChallenge = {}));
function createBaseWelcomePeerInformation() {
    return { peerId: "", availableModules: [] };
}
var WelcomePeerInformation;
(function (WelcomePeerInformation) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.peerId !== "") {
            writer.uint32(10).string(message.peerId);
        }
        for (const v of message.availableModules) {
            writer.uint32(18).string(v);
        }
        return writer;
    }
    WelcomePeerInformation.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWelcomePeerInformation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.peerId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.availableModules.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    WelcomePeerInformation.decode = decode;
    function fromJSON(object) {
        return {
            peerId: isSet(object.peerId) ? String(object.peerId) : "",
            availableModules: Array.isArray(object === null || object === void 0 ? void 0 : object.availableModules)
                ? object.availableModules.map((e) => String(e))
                : [],
        };
    }
    WelcomePeerInformation.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.peerId !== undefined && (obj.peerId = message.peerId);
        if (message.availableModules) {
            obj.availableModules = message.availableModules.map((e) => e);
        }
        else {
            obj.availableModules = [];
        }
        return obj;
    }
    WelcomePeerInformation.toJSON = toJSON;
    function create(base) {
        return WelcomePeerInformation.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    WelcomePeerInformation.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseWelcomePeerInformation();
        message.peerId = (_a = object.peerId) !== null && _a !== void 0 ? _a : "";
        message.availableModules = ((_b = object.availableModules) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    }
    WelcomePeerInformation.fromPartial = fromPartial;
})(WelcomePeerInformation = exports.WelcomePeerInformation || (exports.WelcomePeerInformation = {}));
function createBaseDisconnectionMessage() {
    return { reason: 0 };
}
var DisconnectionMessage;
(function (DisconnectionMessage) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.reason !== 0) {
            writer.uint32(8).int32(message.reason);
        }
        return writer;
    }
    DisconnectionMessage.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDisconnectionMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.reason = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    DisconnectionMessage.decode = decode;
    function fromJSON(object) {
        return { reason: isSet(object.reason) ? disconnectionReasonFromJSON(object.reason) : 0 };
    }
    DisconnectionMessage.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.reason !== undefined && (obj.reason = disconnectionReasonToJSON(message.reason));
        return obj;
    }
    DisconnectionMessage.toJSON = toJSON;
    function create(base) {
        return DisconnectionMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    DisconnectionMessage.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseDisconnectionMessage();
        message.reason = (_a = object.reason) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
    DisconnectionMessage.fromPartial = fromPartial;
})(DisconnectionMessage = exports.DisconnectionMessage || (exports.DisconnectionMessage = {}));
exports.BffAuthenticationServiceDefinition = {
    name: "BffAuthenticationService",
    fullName: "decentraland.bff.BffAuthenticationService",
    methods: {
        getChallenge: {
            name: "GetChallenge",
            requestType: GetChallengeRequest,
            requestStream: false,
            responseType: GetChallengeResponse,
            responseStream: false,
            options: {},
        },
        authenticate: {
            name: "Authenticate",
            requestType: SignedChallenge,
            requestStream: false,
            responseType: WelcomePeerInformation,
            responseStream: false,
            options: {},
        },
        getDisconnectionMessage: {
            name: "GetDisconnectionMessage",
            requestType: empty_gen_1.Empty,
            requestStream: false,
            responseType: DisconnectionMessage,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=authentication_service.gen.js.map