import { Transform } from '@dcl/ecs';
import { assertEquals } from './assert';
export function createTestRuntime(testingModule, engine) {
    let runtimeFrozen = false;
    let currentFrameCounter = 0;
    let currentFrameTime = 0;
    const scheduledTests = [];
    const nextTickFuture = [];
    async function nextTick() {
        return new Promise((resolve) => {
            nextTickFuture.push(resolve);
        });
    }
    engine.addSystem(function TestingFrameworkCoroutineRunner(dt) {
        currentFrameCounter++;
        currentFrameTime += dt;
        nextTickFuture.splice(0, nextTickFuture.length).forEach((_) => _(dt));
    });
    function scheduleValue(value, env) {
        if (value && typeof value === 'object' && typeof value.then === 'function') {
            console.log('⏱️ yield promise');
            nextTickFuture.push(async () => {
                try {
                    scheduleValue(await value, env);
                }
                catch (err) {
                    env.reject(err);
                }
            });
        }
        else if (typeof value === 'function') {
            console.log('⏱️ yield function');
            nextTickFuture.push(() => {
                scheduleValue(value(), env);
            });
            return;
        }
        else if (typeof value === 'undefined' || value === null) {
            console.log('⏱️ yield');
            nextTickFuture.push(() => {
                consumeGenerator(env);
            });
        }
        else
            throw new Error(`Unexpected value from test generator: ${value}`);
    }
    function consumeGenerator(env) {
        try {
            const ret = env.generator.next();
            if (!ret.done) {
                scheduleValue(ret.value, env);
            }
            else {
                env.resolve();
            }
        }
        catch (err) {
            env.reject(err);
        }
    }
    function scheduleNextRun() {
        if (scheduledTests.length) {
            nextTickFuture.push(runTests);
        }
    }
    function runTests() {
        if (scheduledTests.length) {
            const entry = scheduledTests.shift();
            const initialFrame = currentFrameCounter;
            const startTime = currentFrameTime;
            let resolved = false;
            const resolve = () => {
                if (resolved)
                    throw new Error('resolved twice');
                resolved = true;
                console.log(`🟢 Test passed ${entry.name}`);
                testingModule
                    .logTestResult({
                    name: entry.name,
                    ok: true,
                    totalFrames: currentFrameCounter - initialFrame,
                    totalTime: currentFrameTime - startTime
                })
                    .finally(scheduleNextRun);
            };
            const reject = (err) => {
                if (resolved)
                    throw new Error('resolved twice');
                resolved = true;
                console.log(`🔴 Test failed ${entry.name}`);
                console.error(err);
                testingModule
                    .logTestResult({
                    name: entry.name,
                    ok: false,
                    error: err.toString(),
                    stack: err && typeof err === 'object' && err.stack,
                    totalFrames: currentFrameCounter - initialFrame,
                    totalTime: currentFrameTime - startTime
                })
                    .finally(scheduleNextRun);
            };
            try {
                console.log(`🧪 Running test ${entry.name}`);
                const testHelpers = {
                    async setCameraTransform(transform) {
                        await testingModule.setCameraTransform(transform);
                        await nextTick();
                        const TransformComponent = engine.getComponent(Transform.componentId);
                        const actualTransform = TransformComponent.get(engine.CameraEntity);
                        assertEquals(actualTransform.position, transform.position, "positions don't match");
                        assertEquals(actualTransform.rotation, transform.rotation, "rotations don't match");
                    }
                };
                const returnValue = entry.fn(testHelpers);
                if (returnValue && typeof returnValue === 'object') {
                    if (isGenerator(returnValue)) {
                        const env = {
                            generator: returnValue,
                            helpers: testHelpers,
                            resolve,
                            reject
                        };
                        consumeGenerator(env);
                    }
                    else if (isPromise(returnValue)) {
                        returnValue.then(resolve).catch(reject);
                    }
                    else {
                        throw new Error(`Unknown test result type: ${returnValue}`);
                    }
                }
                else {
                    resolve();
                }
            }
            catch (err) {
                reject(err);
            }
        }
    }
    nextTickFuture.push(() => {
        runtimeFrozen = true;
        if (!scheduledTests.length)
            return;
        testingModule.plan({ tests: scheduledTests }).then(scheduleNextRun).catch(globalFail);
    });
    function test(name, fn) {
        if (runtimeFrozen)
            throw new Error("New tests can't be added at this stage.");
        if (scheduledTests.some(($) => $.name === name))
            throw new Error(`Test with name ${name} already exists`);
        scheduledTests.push({ fn, name });
    }
    return {
        test
    };
}
function isGenerator(t) {
    return t && typeof t === 'object' && typeof t[Symbol.iterator] === 'function';
}
function isPromise(t) {
    return t && typeof t === 'object' && typeof t.then === 'function';
}
function globalFail(error) {
    console.error(error);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90ZXN0aW5nL3J1bnRpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFXLFNBQVMsRUFBRSxNQUFNLFVBQVUsQ0FBQTtBQUM3QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sVUFBVSxDQUFBO0FBT3ZDLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxhQUE0QixFQUFFLE1BQWU7SUFVN0UsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFBO0lBRXpCLElBQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFBO0lBQzNCLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFBO0lBR3hCLE1BQU0sY0FBYyxHQUFvQixFQUFFLENBQUE7SUFHMUMsTUFBTSxjQUFjLEdBQWdDLEVBQUUsQ0FBQTtJQUd0RCxLQUFLLFVBQVUsUUFBUTtRQUNyQixPQUFPLElBQUksT0FBTyxDQUFTLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDckMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM5QixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFHRCxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsK0JBQStCLENBQUMsRUFBRTtRQUMxRCxtQkFBbUIsRUFBRSxDQUFBO1FBQ3JCLGdCQUFnQixJQUFJLEVBQUUsQ0FBQTtRQUV0QixjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUN2RSxDQUFDLENBQUMsQ0FBQTtJQUlGLFNBQVMsYUFBYSxDQUFDLEtBQVUsRUFBRSxHQUFzQjtRQUN2RCxJQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksT0FBTyxLQUFLLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUMxRSxPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUE7WUFFL0IsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDN0IsSUFBSTtvQkFDRixhQUFhLENBQUMsTUFBTSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUE7aUJBQ2hDO2dCQUFDLE9BQU8sR0FBRyxFQUFFO29CQUNaLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7aUJBQ2hCO1lBQ0gsQ0FBQyxDQUFDLENBQUE7U0FDSDthQUFNLElBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFO1lBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtZQUVoQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDdkIsYUFBYSxDQUFDLEtBQUssRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFBO1lBQzdCLENBQUMsQ0FBQyxDQUFBO1lBQ0YsT0FBTTtTQUNQO2FBQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtZQUN6RCxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1lBRXZCLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUN2QixnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtTQUNIOztZQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLEtBQUssRUFBRSxDQUFDLENBQUE7SUFDMUUsQ0FBQztJQUdELFNBQVMsZ0JBQWdCLENBQUMsR0FBc0I7UUFDOUMsSUFBSTtZQUNGLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUE7WUFDaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUU7Z0JBQ2IsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUE7YUFDOUI7aUJBQU07Z0JBQ0wsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFBO2FBQ2Q7U0FDRjtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1osR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUNoQjtJQUNILENBQUM7SUFHRCxTQUFTLGVBQWU7UUFDdEIsSUFBSSxjQUFjLENBQUMsTUFBTSxFQUFFO1lBQ3pCLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7U0FDOUI7SUFDSCxDQUFDO0lBR0QsU0FBUyxRQUFRO1FBQ2YsSUFBSSxjQUFjLENBQUMsTUFBTSxFQUFFO1lBQ3pCLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUcsQ0FBQTtZQUNyQyxNQUFNLFlBQVksR0FBRyxtQkFBbUIsQ0FBQTtZQUN4QyxNQUFNLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQTtZQUVsQyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUE7WUFHcEIsTUFBTSxPQUFPLEdBQUcsR0FBRyxFQUFFO2dCQUNuQixJQUFJLFFBQVE7b0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO2dCQUMvQyxRQUFRLEdBQUcsSUFBSSxDQUFBO2dCQUVmLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO2dCQUUzQyxhQUFhO3FCQUNWLGFBQWEsQ0FBQztvQkFDYixJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7b0JBQ2hCLEVBQUUsRUFBRSxJQUFJO29CQUNSLFdBQVcsRUFBRSxtQkFBbUIsR0FBRyxZQUFZO29CQUMvQyxTQUFTLEVBQUUsZ0JBQWdCLEdBQUcsU0FBUztpQkFDeEMsQ0FBQztxQkFDRCxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUE7WUFDN0IsQ0FBQyxDQUFBO1lBRUQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFRLEVBQUUsRUFBRTtnQkFDMUIsSUFBSSxRQUFRO29CQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtnQkFDL0MsUUFBUSxHQUFHLElBQUksQ0FBQTtnQkFFZixPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQTtnQkFDM0MsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFFbEIsYUFBYTtxQkFDVixhQUFhLENBQUM7b0JBQ2IsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO29CQUNoQixFQUFFLEVBQUUsS0FBSztvQkFDVCxLQUFLLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRTtvQkFDckIsS0FBSyxFQUFFLEdBQUcsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDLEtBQUs7b0JBQ2xELFdBQVcsRUFBRSxtQkFBbUIsR0FBRyxZQUFZO29CQUMvQyxTQUFTLEVBQUUsZ0JBQWdCLEdBQUcsU0FBUztpQkFDeEMsQ0FBQztxQkFDRCxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUE7WUFDN0IsQ0FBQyxDQUFBO1lBRUQsSUFBSTtnQkFDRixPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQTtnQkFFNUMsTUFBTSxXQUFXLEdBQWdCO29CQUMvQixLQUFLLENBQUMsa0JBQWtCLENBQUMsU0FBUzt3QkFDaEMsTUFBTSxhQUFhLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUE7d0JBQ2pELE1BQU0sUUFBUSxFQUFFLENBQUE7d0JBRWhCLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFxQixDQUFBO3dCQUN6RixNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFBO3dCQUVuRSxZQUFZLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsUUFBUSxFQUFFLHVCQUF1QixDQUFDLENBQUE7d0JBQ25GLFlBQVksQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUUsdUJBQXVCLENBQUMsQ0FBQTtvQkFDckYsQ0FBQztpQkFDRixDQUFBO2dCQUVELE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUE7Z0JBRXpDLElBQUksV0FBVyxJQUFJLE9BQU8sV0FBVyxLQUFLLFFBQVEsRUFBRTtvQkFDbEQsSUFBSSxXQUFXLENBQUMsV0FBVyxDQUFDLEVBQUU7d0JBQzVCLE1BQU0sR0FBRyxHQUFzQjs0QkFDN0IsU0FBUyxFQUFFLFdBQVc7NEJBQ3RCLE9BQU8sRUFBRSxXQUFXOzRCQUNwQixPQUFPOzRCQUNQLE1BQU07eUJBQ1AsQ0FBQTt3QkFDRCxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQTtxQkFDdEI7eUJBQU0sSUFBSSxTQUFTLENBQUMsV0FBVyxDQUFDLEVBQUU7d0JBQ2pDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFBO3FCQUN4Qzt5QkFBTTt3QkFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixXQUFXLEVBQUUsQ0FBQyxDQUFBO3FCQUM1RDtpQkFDRjtxQkFBTTtvQkFDTCxPQUFPLEVBQUUsQ0FBQTtpQkFDVjthQUNGO1lBQUMsT0FBTyxHQUFRLEVBQUU7Z0JBQ2pCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTthQUNaO1NBQ0Y7SUFDSCxDQUFDO0lBR0QsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFHdkIsYUFBYSxHQUFHLElBQUksQ0FBQTtRQUVwQixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU07WUFBRSxPQUFNO1FBR2xDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3ZGLENBQUMsQ0FBQyxDQUFBO0lBSUYsU0FBUyxJQUFJLENBQUMsSUFBWSxFQUFFLEVBQWdCO1FBQzFDLElBQUksYUFBYTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQTtRQUU3RSxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxpQkFBaUIsQ0FBQyxDQUFBO1FBRXpHLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtJQUNuQyxDQUFDO0lBRUQsT0FBTztRQUNMLElBQUk7S0FDTCxDQUFBO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLENBQU07SUFDekIsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxVQUFVLENBQUE7QUFDL0UsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUFDLENBQU07SUFDdkIsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUE7QUFDbkUsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLEtBQVU7SUFFNUIsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGNyZWF0ZVRlc3RSdW50aW1lIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHRlc3QgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgdGVzdHMuXG4gKi9cblxuaW1wb3J0IHsgSUVuZ2luZSwgVHJhbnNmb3JtIH0gZnJvbSAnQGRjbC9lY3MnXG5pbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tICcuL2Fzc2VydCdcbmltcG9ydCB0eXBlIHsgVGVzdGluZ01vZHVsZSwgVGVzdEZ1bmN0aW9uLCBUZXN0SGVscGVycyB9IGZyb20gJy4vdHlwZXMnXG5cbi8vIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIHRlc3QgcnVudGltZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhbmQgcnVuIHRlc3RzLlxuLy8gSXQgdGFrZXMgYSBgVGVzdGluZ01vZHVsZWAgaW5zdGFuY2UgKGxvYWRlZCBmcm9tIHJlcXVpcmUoJ35zeXN0ZW0vVGVzdGluZycpKSBhbmQgYW4gYElFbmdpbmVgIGluc3RhbmNlIChmcm9tIERlY2VudHJhbGFuZCdzIFNESykuXG4vLyBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgYHRlc3RgIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHRlc3RzLlxuLyogQF9fUFVSRV9fICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGVzdFJ1bnRpbWUodGVzdGluZ01vZHVsZTogVGVzdGluZ01vZHVsZSwgZW5naW5lOiBJRW5naW5lKSB7XG4gIHR5cGUgVGVzdFBsYW5FbnRyeSA9IHsgbmFtZTogc3RyaW5nOyBmbjogVGVzdEZ1bmN0aW9uIH1cbiAgdHlwZSBSdW5uZXJFbnZpcm9ubWVudCA9IHtcbiAgICByZXNvbHZlOiAoKSA9PiB2b2lkXG4gICAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZFxuICAgIGhlbHBlcnM6IFRlc3RIZWxwZXJzXG4gICAgZ2VuZXJhdG9yOiBHZW5lcmF0b3JcbiAgfVxuXG4gIC8vIHRoaXMgZmxhZyBlbnN1cmVzIG5vIHRlc3RzIGFyZSBhZGRlZCBhc3luY2hyb25vdXNseVxuICBsZXQgcnVudGltZUZyb3plbiA9IGZhbHNlXG5cbiAgbGV0IGN1cnJlbnRGcmFtZUNvdW50ZXIgPSAwXG4gIGxldCBjdXJyZW50RnJhbWVUaW1lID0gMFxuXG4gIC8vIGFycmF5IHRvIGhvbGQgdGhlIHNjaGVkdWxlZCB0ZXN0c1xuICBjb25zdCBzY2hlZHVsZWRUZXN0czogVGVzdFBsYW5FbnRyeVtdID0gW11cblxuICAvLyBhbiBhcnJheSBvZiBwcm9taXNlcyB0aGF0IGFyZSByZXNvbHZlZCBvbiB0aGUgbmV4dCBmcmFtZSAoYWZ0ZXIgdGhlIGN1cnJlbnQgZnJhbWUgaXMgZmluaXNoZWQpXG4gIGNvbnN0IG5leHRUaWNrRnV0dXJlOiBBcnJheTwoZHQ6IG51bWJlcikgPT4gdm9pZD4gPSBbXVxuXG4gIC8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbiB0aGUgbmV4dCBmcmFtZVxuICBhc3luYyBmdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8bnVtYmVyPigocmVzb2x2ZSkgPT4ge1xuICAgICAgbmV4dFRpY2tGdXR1cmUucHVzaChyZXNvbHZlKVxuICAgIH0pXG4gIH1cblxuICAvLyBhZGQgYSBzeXN0ZW0gdG8gdGhlIGVuZ2luZSB0aGF0IHJlc29sdmVzIGFsbCBwcm9taXNlcyBpbiB0aGUgYG5leHRUaWNrRnV0dXJlYCBhcnJheVxuICBlbmdpbmUuYWRkU3lzdGVtKGZ1bmN0aW9uIFRlc3RpbmdGcmFtZXdvcmtDb3JvdXRpbmVSdW5uZXIoZHQpIHtcbiAgICBjdXJyZW50RnJhbWVDb3VudGVyKytcbiAgICBjdXJyZW50RnJhbWVUaW1lICs9IGR0XG4gICAgLy8gcmVzb2x2ZSBhbGwgbmV4dFRpY2sgZnV0dXJlcy5cbiAgICBuZXh0VGlja0Z1dHVyZS5zcGxpY2UoMCwgbmV4dFRpY2tGdXR1cmUubGVuZ3RoKS5mb3JFYWNoKChfKSA9PiBfKGR0KSlcbiAgfSlcblxuICAvLyB0aGlzIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIHZhbHVlIHRvIGJlIHByb2Nlc3NlZCBvbiB0aGUgbmV4dCBmcmFtZSwgdGhlIHRlc3QgcnVubmVyIHdpbGxcbiAgLy8gY29udGludWUgdG8gcnVuIHVudGlsIGl0IHJlYWNoZXMgYSB5aWVsZCBwb2ludFxuICBmdW5jdGlvbiBzY2hlZHVsZVZhbHVlKHZhbHVlOiBhbnksIGVudjogUnVubmVyRW52aXJvbm1lbnQpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2coJ+KPse+4jyB5aWVsZCBwcm9taXNlJylcbiAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBhIHByb21pc2UsIHNjaGVkdWxlIGl0IHRvIGJlIGF3YWl0ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgZnJhbWUgaXMgZmluaXNoZWRcbiAgICAgIG5leHRUaWNrRnV0dXJlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNjaGVkdWxlVmFsdWUoYXdhaXQgdmFsdWUsIGVudilcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZW52LnJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfij7HvuI8geWllbGQgZnVuY3Rpb24nKVxuICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIHNjaGVkdWxlIGl0IHRvIGJlIGNhbGxlZCBvbiB0aGUgbmV4dCBmcmFtZVxuICAgICAgbmV4dFRpY2tGdXR1cmUucHVzaCgoKSA9PiB7XG4gICAgICAgIHNjaGVkdWxlVmFsdWUodmFsdWUoKSwgZW52KVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ+KPse+4jyB5aWVsZCcpXG4gICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGNvbnRpbnVlIHByb2Nlc3NpbmcgdGhlIGdlbmVyYXRvciB0aGUgbmV4dCBmcmFtZVxuICAgICAgbmV4dFRpY2tGdXR1cmUucHVzaCgoKSA9PiB7XG4gICAgICAgIGNvbnN1bWVHZW5lcmF0b3IoZW52KVxuICAgICAgfSlcbiAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZyb20gdGVzdCBnZW5lcmF0b3I6ICR7dmFsdWV9YClcbiAgfVxuXG4gIC8vIHRoaXMgZnVuY3Rpb24gcHJvY2Vzc2VzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIGJ5IHNjaGVkdWxpbmcgaXRzIHZhbHVlcyB0byBiZSBwcm9jZXNzZWQgb24gdGhlIG5leHQgZnJhbWVcbiAgZnVuY3Rpb24gY29uc3VtZUdlbmVyYXRvcihlbnY6IFJ1bm5lckVudmlyb25tZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldCA9IGVudi5nZW5lcmF0b3IubmV4dCgpXG4gICAgICBpZiAoIXJldC5kb25lKSB7XG4gICAgICAgIHNjaGVkdWxlVmFsdWUocmV0LnZhbHVlLCBlbnYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnYucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlbnYucmVqZWN0KGVycilcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIHRlc3QgcnVuIG9uIHRoZSBuZXh0IGZyYW1lXG4gIGZ1bmN0aW9uIHNjaGVkdWxlTmV4dFJ1bigpIHtcbiAgICBpZiAoc2NoZWR1bGVkVGVzdHMubGVuZ3RoKSB7XG4gICAgICBuZXh0VGlja0Z1dHVyZS5wdXNoKHJ1blRlc3RzKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoaXMgZnVuY3Rpb24gcnVucyB0aGUgc2NoZWR1bGVkIHRlc3RzXG4gIGZ1bmN0aW9uIHJ1blRlc3RzKCkge1xuICAgIGlmIChzY2hlZHVsZWRUZXN0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gc2NoZWR1bGVkVGVzdHMuc2hpZnQoKSFcbiAgICAgIGNvbnN0IGluaXRpYWxGcmFtZSA9IGN1cnJlbnRGcmFtZUNvdW50ZXJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRGcmFtZVRpbWVcblxuICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2VcblxuICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4gaXQgbWFrZXMgdGhlIGN1cnJlbnQgdGVzdCBwYXNzXG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZWQgdHdpY2UnKVxuICAgICAgICByZXNvbHZlZCA9IHRydWVcblxuICAgICAgICBjb25zb2xlLmxvZyhg8J+foiBUZXN0IHBhc3NlZCAke2VudHJ5Lm5hbWV9YClcblxuICAgICAgICB0ZXN0aW5nTW9kdWxlXG4gICAgICAgICAgLmxvZ1Rlc3RSZXN1bHQoe1xuICAgICAgICAgICAgbmFtZTogZW50cnkubmFtZSxcbiAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgdG90YWxGcmFtZXM6IGN1cnJlbnRGcmFtZUNvdW50ZXIgLSBpbml0aWFsRnJhbWUsXG4gICAgICAgICAgICB0b3RhbFRpbWU6IGN1cnJlbnRGcmFtZVRpbWUgLSBzdGFydFRpbWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maW5hbGx5KHNjaGVkdWxlTmV4dFJ1bilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVqZWN0ID0gKGVycjogYW55KSA9PiB7XG4gICAgICAgIGlmIChyZXNvbHZlZCkgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlZCB0d2ljZScpXG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5S0IFRlc3QgZmFpbGVkICR7ZW50cnkubmFtZX1gKVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcblxuICAgICAgICB0ZXN0aW5nTW9kdWxlXG4gICAgICAgICAgLmxvZ1Rlc3RSZXN1bHQoe1xuICAgICAgICAgICAgbmFtZTogZW50cnkubmFtZSxcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YWNrOiBlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyLnN0YWNrLFxuICAgICAgICAgICAgdG90YWxGcmFtZXM6IGN1cnJlbnRGcmFtZUNvdW50ZXIgLSBpbml0aWFsRnJhbWUsXG4gICAgICAgICAgICB0b3RhbFRpbWU6IGN1cnJlbnRGcmFtZVRpbWUgLSBzdGFydFRpbWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maW5hbGx5KHNjaGVkdWxlTmV4dFJ1bilcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfp6ogUnVubmluZyB0ZXN0ICR7ZW50cnkubmFtZX1gKVxuXG4gICAgICAgIGNvbnN0IHRlc3RIZWxwZXJzOiBUZXN0SGVscGVycyA9IHtcbiAgICAgICAgICBhc3luYyBzZXRDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhd2FpdCB0ZXN0aW5nTW9kdWxlLnNldENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pXG4gICAgICAgICAgICBhd2FpdCBuZXh0VGljaygpXG5cbiAgICAgICAgICAgIGNvbnN0IFRyYW5zZm9ybUNvbXBvbmVudCA9IGVuZ2luZS5nZXRDb21wb25lbnQoVHJhbnNmb3JtLmNvbXBvbmVudElkKSBhcyB0eXBlb2YgVHJhbnNmb3JtXG4gICAgICAgICAgICBjb25zdCBhY3R1YWxUcmFuc2Zvcm0gPSBUcmFuc2Zvcm1Db21wb25lbnQuZ2V0KGVuZ2luZS5DYW1lcmFFbnRpdHkpXG5cbiAgICAgICAgICAgIGFzc2VydEVxdWFscyhhY3R1YWxUcmFuc2Zvcm0ucG9zaXRpb24sIHRyYW5zZm9ybS5wb3NpdGlvbiwgXCJwb3NpdGlvbnMgZG9uJ3QgbWF0Y2hcIilcbiAgICAgICAgICAgIGFzc2VydEVxdWFscyhhY3R1YWxUcmFuc2Zvcm0ucm90YXRpb24sIHRyYW5zZm9ybS5yb3RhdGlvbiwgXCJyb3RhdGlvbnMgZG9uJ3QgbWF0Y2hcIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGVudHJ5LmZuKHRlc3RIZWxwZXJzKVxuXG4gICAgICAgIGlmIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKGlzR2VuZXJhdG9yKHJldHVyblZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZW52OiBSdW5uZXJFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yOiByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgICAgaGVscGVyczogdGVzdEhlbHBlcnMsXG4gICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZUdlbmVyYXRvcihlbnYpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmV0dXJuVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRlc3QgcmVzdWx0IHR5cGU6ICR7cmV0dXJuVmFsdWV9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2NoZWR1bGUgdGhlIHRlc3QgcnVubmVyIHN0YXJ0IGZvciB0aGUgbmV4dCBmcmFtZVxuICBuZXh0VGlja0Z1dHVyZS5wdXNoKCgpID0+IHtcbiAgICAvLyBvbmNlIHdlIHJ1biB0aGUgbmV4dCB0aWNrLCB0aGUgdGVzdCBydW50aW1lIGJlY29tZXMgZnJvemVuLiB0aGF0IG1lYW5zIG5vIG5ld1xuICAgIC8vIHRlc3QgZGVmaW5pdGlvbnMgYXJlIGFjY2VwdGVkXG4gICAgcnVudGltZUZyb3plbiA9IHRydWVcblxuICAgIGlmICghc2NoZWR1bGVkVGVzdHMubGVuZ3RoKSByZXR1cm5cblxuICAgIC8vIGluZm9ybSB0aGUgdGVzdCBydW5uZXIgYWJvdXQgdGhlIHBsYW5zIGZvciB0aGlzIHRlc3QgcnVuXG4gICAgdGVzdGluZ01vZHVsZS5wbGFuKHsgdGVzdHM6IHNjaGVkdWxlZFRlc3RzIH0pLnRoZW4oc2NoZWR1bGVOZXh0UnVuKS5jYXRjaChnbG9iYWxGYWlsKVxuICB9KVxuXG4gIC8vIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBwbGFuIGEgdGVzdCBmdW5jdGlvbm5cbiAgLyogQF9fUFVSRV9fICovXG4gIGZ1bmN0aW9uIHRlc3QobmFtZTogc3RyaW5nLCBmbjogVGVzdEZ1bmN0aW9uKSB7XG4gICAgaWYgKHJ1bnRpbWVGcm96ZW4pIHRocm93IG5ldyBFcnJvcihcIk5ldyB0ZXN0cyBjYW4ndCBiZSBhZGRlZCBhdCB0aGlzIHN0YWdlLlwiKVxuXG4gICAgaWYgKHNjaGVkdWxlZFRlc3RzLnNvbWUoKCQpID0+ICQubmFtZSA9PT0gbmFtZSkpIHRocm93IG5ldyBFcnJvcihgVGVzdCB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApXG5cbiAgICBzY2hlZHVsZWRUZXN0cy5wdXNoKHsgZm4sIG5hbWUgfSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yKHQ6IGFueSk6IHQgaXMgR2VuZXJhdG9yIHtcbiAgcmV0dXJuIHQgJiYgdHlwZW9mIHQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlKHQ6IGFueSk6IHQgaXMgUHJvbWlzZTx1bmtub3duPiB7XG4gIHJldHVybiB0ICYmIHR5cGVvZiB0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEZhaWwoZXJyb3I6IGFueSkge1xuICAvLyBmb3Igbm93LCB0aGUgZmFpbHVyZSBpcyBvbmx5IHdyaXRpbmcgdG8gdGhlIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG59XG4iXX0=