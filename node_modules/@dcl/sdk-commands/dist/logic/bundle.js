"use strict";
// this file is tested extensively to build scenes in the `make test` command
// but since it runs outiside the testing harness, coverage is not collected
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleSingleProject = exports.bundleProject = void 0;
const child_process_1 = __importDefault(require("child_process"));
const esbuild_1 = __importDefault(require("esbuild"));
const fp_future_1 = require("fp-future");
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
const log_1 = require("../components/log");
const beautiful_logs_1 = require("./beautiful-logs");
const error_1 = require("./error");
const composite_1 = require("./composite");
const MAX_STEP = 2;
/**
 * Generate the entry-point code for a given original entry-point
 * @param entrypointPath - file to be imported as original entry point
 * @param forceCustomExport
 * @returns the Typescript code
 */
function getEntrypointCode(entrypointPath, forceCustomExport) {
    const unixEntrypointPath = entrypointPath.replace(/(\\)/g, '/');
    if (forceCustomExport)
        return `;"use strict";export * from '${unixEntrypointPath}'`;
    return `// BEGIN AUTO GENERATED CODE "~sdk/scene-entrypoint"
"use strict";
import * as entrypoint from '${unixEntrypointPath}'
import { engine } from '@dcl/sdk/ecs'
import * as sdk from '@dcl/sdk'

if ((entrypoint as any).main !== undefined) {
  function _INTERNAL_startup_system() {
    const maybePromise = (entrypoint as any).main()
    if (maybePromise && typeof maybePromise === 'object' && typeof (maybePromise as unknown as Promise<unknown>).then === 'function') {
      maybePromise.catch(console.error)
    }
    engine.removeSystem(_INTERNAL_startup_system)
  }
  engine.addSystem(_INTERNAL_startup_system, Infinity)
}

export * from '@dcl/sdk'
export * from '${unixEntrypointPath}'
`;
}
async function bundleProject(components, options, sceneJson) {
    const tsconfig = path_1.default.join(options.workingDirectory, 'tsconfig.json');
    /* istanbul ignore if */
    if (!options.single && !sceneJson.main) {
        throw new error_1.CliError('scene.json .main must be present');
    }
    /* istanbul ignore if */
    if (sceneJson.runtimeVersion !== '7') {
        throw new error_1.CliError('scene.json `"runtimeVersion": "7"` must be present');
    }
    /* istanbul ignore if */
    if (!(await components.fs.fileExists(tsconfig))) {
        throw new error_1.CliError(`File ${tsconfig} must exist to compile the Typescript project`);
    }
    const entrypointSource = options.single ?? 'src/index.ts';
    const entrypoints = (0, glob_1.globSync)(entrypointSource, { cwd: options.workingDirectory, absolute: true });
    /* istanbul ignore if */
    if (!entrypoints.length)
        throw new error_1.CliError(`There are no input files to build: ${entrypointSource}`);
    // const output = !options.single ? sceneJson.main : options.single.replace(/\.ts$/, '.js')
    // const outfile = path.join(options.workingDirectory, output)
    const inputs = options.single
        ? entrypoints.map((entrypoint) => ({ entrypoint, outputFile: entrypoint.replace(/\.ts$/, '.js') }))
        : [{ entrypoint: entrypoints[0], outputFile: sceneJson.main }];
    for (const input of inputs) {
        await bundleSingleProject(components, {
            ...options,
            tsconfig,
            ...input
        });
    }
    return { sceneJson, inputs };
}
exports.bundleProject = bundleProject;
async function bundleSingleProject(components, options) {
    (0, beautiful_logs_1.printProgressStep)(components.logger, `Bundling file ${log_1.colors.bold(options.entrypoint)}`, 1, MAX_STEP);
    const context = await esbuild_1.default.context({
        bundle: true,
        platform: 'browser',
        format: 'cjs',
        preserveSymlinks: false,
        outfile: options.outputFile,
        allowOverwrite: false,
        sourcemap: options.production ? 'external' : 'inline',
        minify: options.production,
        minifyIdentifiers: options.production,
        minifySyntax: options.production,
        minifyWhitespace: options.production,
        treeShaking: true,
        metafile: true,
        absWorkingDir: options.workingDirectory,
        target: 'es2020',
        external: ['~system/*', '@dcl/inspector', '@dcl/inspector/*' /* ban importing the inspector from the SDK */],
        // convert filesystem paths into file:// to enable VSCode debugger
        sourceRoot: (0, url_1.pathToFileURL)(path_1.default.dirname(options.outputFile)).toString(),
        define: {
            document: 'undefined',
            window: 'undefined',
            DEBUG: options.production ? 'false' : 'true',
            'globalThis.DEBUG': options.production ? 'false' : 'true',
            'process.env.NODE_ENV': JSON.stringify(options.production ? 'production' : 'development')
        },
        tsconfig: options.tsconfig,
        supported: {
            'import-assertions': false,
            'import-meta': false,
            'dynamic-import': false,
            hashbang: false
        },
        logOverride: {
            'import-is-undefined': 'silent'
        },
        plugins: [compositeLoader(components, options)],
        stdin: {
            contents: getEntrypointCode(options.entrypoint, options.customEntryPoint),
            resolveDir: path_1.default.dirname(options.entrypoint),
            sourcefile: path_1.default.basename(options.entrypoint) + '.entry-point.ts',
            loader: 'ts'
        }
    });
    /* istanbul ignore if */
    if (options.watch) {
        await context.watch({});
        (0, beautiful_logs_1.printProgressInfo)(components.logger, `Bundle saved ${log_1.colors.bold(options.outputFile)}`);
    }
    else {
        try {
            await context.rebuild();
            (0, beautiful_logs_1.printProgressInfo)(components.logger, `Bundle saved ${log_1.colors.bold(options.outputFile)}`);
        }
        catch (err) {
            /* istanbul ignore next */
            throw new error_1.CliError(err.toString());
        }
        await context.dispose();
    }
    /* istanbul ignore next */
    if (options.watch)
        (0, beautiful_logs_1.printProgressInfo)(components.logger, `The compiler is watching for changes`);
    await runTypeChecker(components, options);
}
exports.bundleSingleProject = bundleSingleProject;
function runTypeChecker(components, options) {
    const args = [
        require.resolve('typescript/lib/tsc'),
        '-p',
        'tsconfig.json',
        '--preserveWatchOutput',
        options.emitDeclaration ? '--emitDeclarationOnly' : '--noEmit'
    ];
    /* istanbul ignore if */
    if (options.watch)
        args.push('--watch');
    (0, beautiful_logs_1.printProgressStep)(components.logger, `Running type checker`, 2, MAX_STEP);
    const ts = child_process_1.default.spawn('node', args, { env: process.env, cwd: options.workingDirectory });
    const typeCheckerFuture = (0, fp_future_1.future)();
    ts.on('close', (code) => {
        /* istanbul ignore else */
        if (code === 0) {
            (0, beautiful_logs_1.printProgressInfo)(components.logger, `Type checking completed without errors`);
        }
        else {
            typeCheckerFuture.reject(new error_1.CliError(`Typechecker exited with code ${code}.`));
            return;
        }
        typeCheckerFuture.resolve(code);
    });
    ts.stdout.pipe(process.stdout);
    ts.stderr.pipe(process.stderr);
    /* istanbul ignore if */
    if (options.watch) {
        typeCheckerFuture.resolve(-1);
    }
    return typeCheckerFuture;
}
function compositeLoader(components, options) {
    let shouldReload = true;
    let contents = `export const compositeFromLoader = {}`; // default exports nothing
    let watchFiles = []; // no files to watch
    let lastBuiltSuccessful = false;
    return {
        name: 'composite-loader',
        setup(build) {
            build.onStart(() => {
                shouldReload = true;
            });
            build.onResolve({ filter: /~sdk\/all-composites/ }, (_args) => {
                return {
                    namespace: 'sdk-composite',
                    path: 'all-composites'
                };
            });
            build.onLoad({ filter: /.*/, namespace: 'sdk-composite' }, async (_) => {
                if (shouldReload) {
                    if (!options.ignoreComposite) {
                        const data = await (0, composite_1.getAllComposites)(components, 
                        // we pass the build.initialOptions.absWorkingDir to build projects with multiple roots at once
                        build.initialOptions.absWorkingDir ?? options.workingDirectory);
                        contents = `export const compositeFromLoader = {${data.compositeLines.join(',')}}`;
                        watchFiles = data.watchFiles;
                        if (data.withErrors) {
                            (0, beautiful_logs_1.printWarning)(components.logger, 'Some composites are not included because of errors while compiling them. There can be unexpected behavior in the scene, check the errors and try to fix them.');
                        }
                        else if (!lastBuiltSuccessful) {
                            components.logger.log('Composites built without errors.');
                        }
                        lastBuiltSuccessful = !data.withErrors;
                    }
                    shouldReload = false;
                }
                return {
                    loader: 'js',
                    contents,
                    watchFiles
                };
            });
        }
    };
}
//# sourceMappingURL=bundle.js.map