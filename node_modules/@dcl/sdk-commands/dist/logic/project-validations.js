"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startValidations = exports.npmCommand = exports.npmRun = exports.installDependencies = exports.needsDependencies = exports.assertValidProjectFolder = void 0;
const path_1 = __importDefault(require("path"));
const log_1 = require("../components/log");
const beautiful_logs_1 = require("./beautiful-logs");
const error_1 = require("./error");
const scene_validations_1 = require("./scene-validations");
const config_1 = require("./config");
/**
 * Asserts that the workingDirectory is a valid project
 */
async function assertValidProjectFolder(components, workingDirectory) {
    // no validations for now, only check that it exists
    if (!(await components.fs.fileExists(path_1.default.resolve(workingDirectory, 'package.json'))))
        throw new error_1.CliError(`The project root doesn't have a package.json file`);
    // now we will iterate over different file to evaluate the project kind
    switch (true) {
        // TODO: case wearable
        // case scene
        case await components.fs.fileExists((0, scene_validations_1.getSceneFilePath)(workingDirectory)): {
            return { kind: 'scene', scene: await (0, scene_validations_1.getValidSceneJson)(components, workingDirectory), workingDirectory };
        }
        default: {
            throw new error_1.CliError(`UnknownProjectKind: the kind of project of the folder ${workingDirectory} cannot be identified`);
        }
    }
}
exports.assertValidProjectFolder = assertValidProjectFolder;
/*
 * Returns true if the project contains an empty node_modules folder
 */
async function needsDependencies(components, workingDirectory) {
    const nodeModulesPath = path_1.default.join(workingDirectory, 'node_modules');
    const hasNodeModulesFolder = await components.fs.directoryExists(nodeModulesPath);
    const isNodeModulesEmpty = hasNodeModulesFolder && (await components.fs.readdir(nodeModulesPath)).length === 0;
    return !hasNodeModulesFolder || isNodeModulesEmpty;
}
exports.needsDependencies = needsDependencies;
/* istanbul ignore next */
const npmBin = /^win/.test(process.platform) ? 'npm.cmd' : 'npm';
/*
 * Runs "npm install" for desired project
 */
async function installDependencies(components, workingDirectory) {
    (0, beautiful_logs_1.printProgressInfo)(components.logger, 'Installing dependencies...');
    // TODO: test in windows
    await components.spawner.exec(workingDirectory, npmBin, ['install']);
    (0, beautiful_logs_1.printProgressInfo)(components.logger, log_1.colors.white('âœ… Installing dependencies...'));
}
exports.installDependencies = installDependencies;
/**
 * Run NPM commands
 */
async function npmRun(components, cwd, command, ...args) {
    // TODO: test in windows
    await components.spawner.exec(cwd, npmBin, ['run', command, '--silent', '--', ...args], { env: process.env });
}
exports.npmRun = npmRun;
/**
 * NPM commands
 */
async function npmCommand(components, cwd, command, ...args) {
    await components.spawner.exec(cwd, npmBin, [command, ...args, '--silent'], { env: process.env });
}
exports.npmCommand = npmCommand;
/**
 * Start validations to make the scene work.
 */
async function startValidations(components, cwd) {
    try {
        const sdkVersion = await (0, config_1.getInstalledPackageVersion)(components, '@dcl/sdk', cwd);
        await npmCommand(components, cwd, `install --save-exact -D @dcl/js-runtime@${sdkVersion}`);
    }
    catch (_) {
        components.logger.error('Failed to run scene validations');
    }
}
exports.startValidations = startValidations;
//# sourceMappingURL=project-validations.js.map