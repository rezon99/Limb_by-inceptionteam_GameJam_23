"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setRoutes = void 0;
const path_1 = require("path");
const url_1 = __importDefault(require("url"));
const http_server_1 = require("@well-known-components/http-server");
const schemas_1 = require("@dcl/schemas");
const fp_future_1 = __importDefault(require("fp-future"));
const catalyst_requests_1 = require("../../../logic/catalyst-requests");
const coordinates_1 = require("../../../logic/coordinates");
function getContentType(type) {
    switch (type) {
        case 'css':
            return 'text/css';
        case 'js':
            return 'application/js';
        case 'media':
        default:
            return 'text/plain';
    }
}
function setRoutes(components, files, sceneInfo) {
    const futureSignature = (0, fp_future_1.default)();
    const { fs, logger } = components;
    const router = new http_server_1.Router();
    const linkerDapp = (0, path_1.dirname)(require.resolve('@dcl/linker-dapp/package.json'));
    let deployInfo = {};
    router.get('/', async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'index.html'))
    }));
    router.get('/static/:type/:path', async (ctx) => {
        const contentType = getContentType(ctx.params.type);
        return {
            headers: { 'Content-Type': contentType },
            body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'static', ctx.params.type, ctx.params.path))
        };
    });
    router.get('/manifest.json', async () => ({
        headers: { 'Content-Type': 'application/json' },
        body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'manifest.json'))
    }));
    router.get('/api/info', async () => ({
        body: sceneInfo
    }));
    router.get('/api/files', async () => ({
        body: files.map((file) => ({
            name: file.path,
            size: file.size
        }))
    }));
    router.get('/api/catalyst-pointers', async () => {
        const { x, y } = (0, coordinates_1.getObject)(sceneInfo.baseParcel);
        const pointer = `${x},${y}`;
        const chainId = deployInfo.linkerResponse?.chainId || 1;
        const network = chainId === schemas_1.ChainId.ETHEREUM_MAINNET ? 'mainnet' : 'goerli';
        const value = await (0, catalyst_requests_1.getPointers)(components, pointer, network);
        return {
            body: {
                catalysts: value,
                status: deployInfo.status ?? ''
            }
        };
    });
    router.get('/api/close', async (ctx) => {
        const { ok, reason } = url_1.default.parse(ctx.url.toString(), true).query;
        if (ok === 'true') {
            const value = JSON.parse(reason?.toString() || '{}');
            deployInfo = { ...deployInfo, linkerResponse: value };
            futureSignature.resolve(value);
            return {};
        }
        futureSignature.reject(new Error(`Failed to link: ${reason}`));
        return {};
    });
    router.post('/api/deploy', async (ctx) => {
        const value = (await ctx.request.json());
        if (!value.address || !value.signature || !value.chainId) {
            logger.error(`Invalid payload: ${Object.keys(value).join(' - ')}`);
            return {};
        }
        deployInfo = { ...deployInfo, linkerResponse: value, status: 'deploying' };
        futureSignature.resolve(value);
        return {};
    });
    return { router, futureSignature };
}
exports.setRoutes = setRoutes;
//# sourceMappingURL=routes.js.map