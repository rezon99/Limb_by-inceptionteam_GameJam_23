"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runLinkerApp = void 0;
const http_server_1 = require("@well-known-components/http-server");
const interfaces_1 = require("@well-known-components/interfaces");
const env_config_provider_1 = require("@well-known-components/env-config-provider");
const logger_1 = require("@well-known-components/logger");
const path_1 = require("path");
const schemas_1 = require("@dcl/schemas");
const querystring_1 = __importDefault(require("querystring"));
const open_1 = __importDefault(require("open"));
const get_free_port_1 = require("../../../logic/get-free-port");
const beautiful_logs_1 = require("../../../logic/beautiful-logs");
const routes_1 = require("./routes");
const config_1 = require("../../../logic/config");
const fp_future_1 = __importDefault(require("fp-future"));
async function runLinkerApp(cliComponents, scene, files, port, rootCID, { isHttps, skipValidations, openBrowser }) {
    const resolvedPort = await (0, get_free_port_1.getPort)(port);
    const sceneInfo = await getSceneInfo(cliComponents, scene, rootCID, skipValidations);
    const protocol = isHttps ? 'https' : 'http';
    const queryParams = querystring_1.default.stringify(sceneInfo);
    const url = `${protocol}://localhost:${resolvedPort}`;
    const futureResponse = (0, fp_future_1.default)();
    const program = await interfaces_1.Lifecycle.run({
        async initComponents() {
            const config = (0, env_config_provider_1.createRecordConfigComponent)({
                HTTP_SERVER_PORT: resolvedPort.toString(),
                HTTP_SERVER_HOST: '0.0.0.0',
                ...process.env
            });
            const logs = await (0, logger_1.createConsoleLogComponent)({});
            const https = isHttps ? await getCredentials(cliComponents) : undefined;
            const server = await (0, http_server_1.createServerComponent)({ ...cliComponents, config, logs }, { https, cors: {} });
            return { ...cliComponents, config, logs, server };
        },
        async main({ components, startComponents }) {
            const { router, futureSignature } = (0, routes_1.setRoutes)(components, files, sceneInfo);
            components.server.setContext(components);
            components.server.use(router.allowedMethods());
            components.server.use(router.middleware());
            await startComponents();
            if (openBrowser)
                await browse(components, url, queryParams);
            const value = await futureSignature;
            (0, beautiful_logs_1.printSuccess)(components.logger, `\nContent successfully signed.`, '');
            components.logger.info(`Address: ${value.address}`);
            components.logger.info(`Signature: ${value.signature}`);
            components.logger.info(`Network: ${(0, schemas_1.getChainName)(value.chainId)}`);
            futureResponse.resolve(value);
        }
    });
    return { program, linkerResponse: futureResponse };
}
exports.runLinkerApp = runLinkerApp;
async function browse({ logger }, url, params) {
    logger.info('You need to sign the content before the deployment:');
    setTimeout(async () => {
        try {
            await (0, open_1.default)(`${url}?${params}`);
        }
        catch (e) {
            logger.error(`Unable to open browser automatically. Please manually navigate to:\n  ${url}?${params}`);
        }
    }, 5000);
    logger.info(`Signing app ready at ${url}?${params}`);
}
async function getCredentials({ fs }) {
    const privateKey = await fs.readFile((0, path_1.resolve)(__dirname, '../../../certs/localhost.key'), 'utf-8');
    const certificate = await fs.readFile((0, path_1.resolve)(__dirname, '../../../certs/localhost.crt'), 'utf-8');
    return { key: privateKey, cert: certificate };
}
async function getSceneInfo(components, scene, rootCID, skipValidations) {
    const { scene: { parcels, base }, display } = scene;
    return {
        baseParcel: base,
        parcels,
        rootCID,
        landRegistry: await (0, config_1.getLandRegistry)(components),
        estateRegistry: await (0, config_1.getEstateRegistry)(components),
        debug: !!process.env.DEBUG,
        title: display?.title,
        description: display?.description,
        skipValidations
    };
}
//# sourceMappingURL=api.js.map